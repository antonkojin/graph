% !TEX root = ./facebook.tex
\documentclass[a4paper, 11pt]{article}
\usepackage[latin1]{inputenc}
%\usepackage[T1]{fontenc}
\usepackage[italian]{babel}
\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{
  %language=C,
  breaklines=true,
  basicstyle=\footnotesize\ttfamily,
  showstringspaces=false,
  captionpos=b,
  brackgroundcolor=,
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{mygray},
  frame=l,
  backgroundcolor=\color{white},
  commentstyle=\color{mygreen},
  keywordstyle=\color{blue},
  rulecolor=\color{black},
  stringstyle=\color{mymauve},
  tabsize=2
  %keywordstyle=\bfseries\color{green},
  %commentstyle=\itshape\color{purple},
  %identifierstyle=\color{blue},
  %stringstyle=\color{orange}
}

\begin{document}

\title{
  {Progetto Algoritmi e Strutture Dati} \\
  {Facebook}
}
\author{ Anton Kozhin }
\date{\today}
\maketitle

\section{Introduzione}
Il progetto consiste nel

\section{Strutture dati e algoritmi}
Ho deciso di rappresentare gli utenti come nodi di un grafo non orientato e
le relazioni di amicizia come archi del grafo.
Un albero binario di ricerca %albero 2-3 ???
per trovare un utente dato il suo
identificativo.
L'algoritmo per la ricerca di gruppo di amici è la ricerca di componenti connesse.
\subsection{Grafo Utenti}
Facebook è composto da utenti e la relazione di amicizia tra due utenti. Una naturale rappresentazione delle relazioni è il grafo. Quindi facebook verrà rappresentato da un grafo non orientato e la relazione di amicizia come l'arco tra due vertici del grafo.

Rappresento gli archi con una lista di adiacenza, supponendo che il grafo sia poco connesso, visto che non tutti sono amici di tutti. Ho bisogno di una struttura dati composta per l'arco (\lstinline{edge}), poichè voglio memorizzare anche l'anno in cui si crea l'amicizia.
\lstinputlisting[language=C, firstline=17, lastline=22]{../codice/graph.h}

\lstinputlisting[language=C, firstline=10, lastline=16]{../codice/graph.h}

\lstinputlisting[language=C, firstline=4, lastline=8]{../codice/graph.h}
\lstinline{bst} è un albero binario di ricerca.

\subsubsection{Inserimento Utente}
Inserire un nuovo utente equivale a inserire un nuovo vertice nel grafo.
\begin{lstlisting}[mathescape]
aggiungi_vertice($G = (V,E)$, $v$):
  se $v \notin V$ allora:
    $V := V \cup \{v\}$
    inserisci $v$ nell'albero binario di ricerca di $V$
  altrimenti:
    stampa errore
  return $G$
\end{lstlisting}
Una stima della complesssita computazionale col criterio uniforme.
Per verificare se $v \notin V$ faccio una ricerca nell'albero, ci si impiega $O(\log_{2}n)$ nel caso medio, dove $n$ è il numero di vertici nel grafo.
Il tempo per aggiungere $v$ all'insieme dei vertici $V$ è costante, si tratta di appenderlo in testa alla lista dei gertici di $G$.
Il tempo per inserire $v$ nell'albero di ricerca è anche lui logarimico.
\[
T_{aggiungi\_vertice} = O(\log_{2}n) + O(1) + O(\log_{2}n) = O(\log_{2}n)
\]

\subsubsection{Inserimento amicizia}
La seguente procedura ha come argomenti un grafo $G$, gli identificativi di due utenti \lstinline{id_u1} e \lstinline{id_u2} e il \lstinline{valore} da assegnare all'arco che colleghera i due vertici relativi ai due utenti. \lstinline[mathescape]{bst($G$)} restituisce l'albero binario di ricerca di $G$. $L($v$)$ restituisce la lista di adiacenza del vertice v.
\begin{lstlisting}[mathescape]
inserisci_amicizia($G=(V,E)$, id$_1$, id$_2$, valore)
  v$_1$ := ricerca_utente( bst($G$), id$_1$ )
  v$_2$ := ricerca_utente( bst($G$), id$_2$ )
  list_append( $L($v$_1)$, v$_2$, valore )
  list_append( $L($v$_2)$, v$_1$, valore )
\end{lstlisting}
\lstinline{ricerca_utente} costa $O(\log_{2}n)$. \lstinline{list_append} ha costo $O(1)$, è un inserimento in testa a una lista.
\[
  T_{inserisci\_amicizia} = 2 O(\log_{2}n) + 2O(1) = O(\log_{2}n)
\]
\subsection{Albero binario di ricerca Utenti}
Ho implementato l'albero binario di ricerca per cercare un utente dato il suo identificativo. Altrimenti avrei dovuto cercare l'utente nella lista dei vertici, col costo di $O(n)$.
\lstinputlisting[language=C, firstline=4, lastline=7]{../codice/binary_search_tree.h}

\subsubsection{Ricerca utente}
L'operazione di ricerca di un utente si traduce in una ricerca del suo identificativo nell'albero binario di ricerca (d'ora in poi \lstinline{BST}).
La funzione \lstinline{id} restituisce l'identificativo relativo all'utente rappresentato dal nodo. La funzione \lstinline{dato} restituisce il dato a cui punta il nodo, in questo caso l'utente.
Banalmente le funzioni \lstinline{figlio_destro} e \lstinline{figlio_sinistro} restituiscono rispettivamente il figlio destro o sinistro del nodo.
\begin{lstlisting}[mathescape]
ricerca_utente(root, id_utente)
  if root = NULL
    return NULL
  if id_utente = id(root)
    return dato(root)
  else if id_utente < id(root)
    return ricerca_utente(figlio_sinistro(root), id_utente)
  else
    return ricerca_utente(figlio_destro(root), id_utente)
\end{lstlisting}
Questa procedura ricorsiva trova un utente in tempo $O(h)$ dove $h = \log_{2}n$ è l'altezza dell'albero, se supponiamo che l'albero sia bilanciato, cioè gli utenti inseriti in ordine sparso.
Tuttavia, nel caso peggiore, cioè se gli utenti sono inseriti in ordine crescente o decrescente di identificativo, l'albero degenera in una lista concatenata, e quindi la ricerca impiega $O(|V|)$.
\[
  T_{ricerca\_utente}^{medio}(n) = O(\log_{2}n)
\]
\[
  T_{ricerca\_utente}^{peggiore}(n) = O(n)
\]
\subsubsection{Inserimento utente nell'albero}
Nell'ambito del progetto questa procedura è eseguita solo se l'utente non è gia presente. %Definisco \lstinline{&x} come l'indirizzo di memoria di \lstinline{x}.
\begin{lstlisting}[mathescape]
inserisci_nodo(root, elemento):
  if root = NULL
    root = elemento
  else if id(elemento) < id(root)
    if figlio_sinistro(root) = NULL
      aggiungi_sinistro(root, elemento)
    else
      inserisci_nodo( figlio_sinistro(root), elemento )
  else
    if figlio_destro(root) = NULL
      aggiungi_destro(root, elemento)
    else
      inserisci_nodo( figlio_destro(root), elemento )
\end{lstlisting}
Per questa procedura valgono le stesse considerazoni della rocedura \lstinline{ricerca_utente} presentata sopra.
\[
  T_{inserisci\_nodo}^{medio}(n) = O(\log_{2}n)
\]
\[
  T_{inserisci\_nodo}^{peggiore}(n) = O(n)
\]

\subsection{Gruppi di amici}
Dato un grafo degli utenti $G$, trovare i gruppi di amici.
Dalle specifiche si evince che un gruppo di amici è una componente connesa di $G$. $L(v)$ restituisce la lista dei vertici adiacenti al vertice $v$. $M(v)$ restituisce \lstinline{true} o \lstinline{false} a seconda se il vertice è stato marcato o meno come visitato.
\begin{lstlisting}[mathescape]
componenti_connesse( $G=(V,E)$ )
  componenti := NULL  // lista vuota
  for each $v\in V$
    $M(v)$ := false
  for each $v \in V$
    if $M(v)$ = false
      list_append( componenti, profondità($v$) );
  return componenti

profondità($v$)
  componente := NULL  // lista vuota
  list_append( componente, $v$)
  $M(v)$ := true
  for each $w \in L(v)$
    if $M(w)$ = false
    list_merge( componente, profondità($w$) )
  return componente
\end{lstlisting}
\lstinline{list_append(lista, elemento)} inserisce in testa alla \lstinline{lista} l'\lstinline{elemento} in tempo $O(1)$. \lstinline[mathescape]{list_merge(lista$_1$, lista$_2$)} concatena le due liste, ciò richiede di trovare la coda di \lstinline[mathescape]{lista$_1$} che ha complessità $O(l)$ dove $l$ è la lunghezza di \lstinline[mathescape]{lista$_1$}.
Si ricorda inoltre che il costo complessivo delle chiamate a \lstinline{profondità} è la somma delle lunghezze delle liste di adiacenza e che $\displaystyle \sum_{v \in V}{|L(v)|} = 2 \times |E| = O(|E|)$.
\[
  T_{componenti\_connesse} = O(|V|) + \sum_{v \in V}{T_{profondità}(v)} = O(|V|) + \sum_{v \in V}{|L(v)|} = O(|V| +|E|)
\]
\subsubsection{Dopo anno X}

%-------------------------------------
\section{Conclusion}
\end{document}
